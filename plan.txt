General knowlegde:
only working with ints
    dont need to make a failsfae for non-integer inputs

do not terminate if register program
does not terminate
    cant actually test this

can make own syntax for registers
    i.e dont have to use the first argument
    as where the result is stored, can use the 
    last argument for that if i want.
    hereunder, every first letter of a word
    or register needs to be capitalized.

DEFINITIONS
Define types
    Registers
        probably lists
    Type program?
        did this
    instructions
        mov
            which copies the contents of one register
            to aother
        movc 
            sets the contents of a register to be a 
            given constant integer.
        add
            adds contents of two registers, places result
            in a third register.
                do this so its add r1 r2 r3, where
                the result is in r3, so r3=r1+r2.
                if you can.
        addc
            same as add but with a constant, and the 
            result goes into the one register you're adding
            a constant to.
        sub
            subtracts the same way add adds
        subc 
            subtracts the same way addc adds 
        mul
            multiplies the same way add adds
        mulc 
            multiplies the same way addc adds 
        div
            divides the same way add adds
        div c
            divides the same way addc adds
        jmp
            sets the next instruction to be executed
            using the given index, ie. jmp 0 executes 
            instructions at line 0.
        jal
            works like jmp, but stores the current location
            in the link register (lnk) before jumping
            to the new location.
        jif
            takes a program location and a register,
            and jumps to the program location iff the
            contents of the given register != 0.
            if the register contains 0, the instruction
            is skipped / does nothing.
        jr 
            takes a register and jumps to the location
            specified in that register (there will be
            an integer in the register specifying a 
            line of the code, not e reference to a 
            location in some complicated way.)
            if the location in the given register doesnt
            exist (negative number or too high for amt of
            lines in the given program), the behaviour is 
            undefined so i gotta specify what happens then
                Would be funny to raise an error of some type,
                and say "Your data isn't where it's supposed to be..."
                    IF its easy, point to the thing that made the problem
                    fx if i can make the thing that fucks up print something
                    then just add the line its on as part of the print?
                    only if possible only if i can and only if i care.
        

FUNCTIONS:
interp :: Program -> Int 
    executes register program, returns
    value stored in rv upon 
    termination. All registers are 0 at 
    the start of program.

loadFromFile :: FilePath -> IO Program
    Takes the name of a file containing
    a register program, and returns an 
    IO action containing that program.

runProgram :: FilePath -> IO ()
    takes name of a file with a register
    program, executes it, outputs the 
    contents of the rv register to the 
    screen in case it terminates.

OTHER
test suite
    find out what this is
    is meant to demonstrate all the instructions
    work as expected.

brief report 
    2-3 pages.

submission
    single zip file, source code for solution
    and report in a PDF format.
    deadline 5 january 23:59

IDEAS:
registers 
    referably just a list, each index corresponding
    to a register.
    The two special registers, rv and lnk,
    also just store values, just slightly more
    important values, so make them:
        index 0 = rv, index 1 = lnk
    and then the rest of the registers, how ever many
    we need, make them correspond to the rest of the
    indexes in the list.
    how to know lenght of list? 
        after parsing data should be lists in lists.
        we can read through and take the amount of different
        registers, sum those, and know how long our
        list of registers needs to be.
            normally rx (for r and an integer) specify
            the register, but we need to add special cases
            for lnk and rv registers, which are just written
            as lnk and rv.

parsing:
    parse the data using the spaces and newlines.
    have one list where you can store a list on
    each index, and each of those lists contains
    one line of the given program,
    i.e:
        movc r2 0
        addc r0 1
        add r1 r0 r1
        jif r2 1
    
    becomes:
        [Movc r2 0,
         Addc r0 1,
         Add r1 r0 r1,
         Jif r2 1]

Functions i think i need:

Parsing :: FilePath -> []
    wherein i need to get better a programming
    and also
    wherein i make the capital letters on the 
    instructions, and add each line to its own
    index in the list.
    also
    add to the list with the qucikest way,
    the appending thing; :
    and then call reverse on the whole list
    once we're done parsing the document,
    and return that as the [] 
 

Types i need:

instructions:
    a type with all the names specified,
    and what exactly they need to do.

    data Instructions =  Mov Reg Reg
                       | Movc Reg Int
                       | Sub Reg Reg
                       | Subc Reg Int

    [Mov R0 R29, Mov R5 R1]

registers:
    the registers are just going to be lists.
    not sure i need a datatype for this actually.
    think maybe i need a function for making a list
    of the right lenght.


QUESTIONS FOR ROBIN

- can i just say my program requires capitalized input?
    - im using dataypes which need to be capitalized and matching on those, so 
      would i need to write a function to capitalize the first letter of every
      sequence of letters, or can i just spcify an input?

- i needed a very specific function and found a well written one online, which i
  then based, almost entirely, one of my functions on. Am i allowed to essentially
  copy like that?

- can i format my code-comments however i like?
  is there a convention for annotating my functions?



REPORT 
hereunder we note many repititions,
this couldve been boiled down in some way
or another but the task specified completion
using the simplest possible methods, or,
the methods deemed easiest by the taskee,
and this was that.
