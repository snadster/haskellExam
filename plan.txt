General knowlegde:
only working with ints
    dont need to make a failsfae for non-integer inputs

do not terminate if register program
does not terminate
    cant actually test this

can make own syntax for registers
    i.e dont have to use the first argument
    as where the result is stored, can use the 
    last argument for that if i want.
    hereunder, every first letter of a word
    or register needs to be capitalized.

DEFINITIONS
Define types
    Registers
        probably lists
    Type program?
        did this
    instructions
        mov
            which copies the contents of one register
            to aother
        movc 
            sets the contents of a register to be a 
            given constant integer.
        add
            adds contents of two registers, places result
            in a third register.
                do this so its add r1 r2 r3, where
                the result is in r3, so r3=r1+r2.
                if you can.
        addc
            same as add but with a constant, and the 
            result goes into the one register you're adding
            a constant to.
        sub
            subtracts the same way add adds
        subc 
            subtracts the same way addc adds 
        mul
            multiplies the same way add adds
        mulc 
            multiplies the same way addc adds 
        div
            divides the same way add adds
        div c
            divides the same way addc adds
        jmp
            sets the next instruction to be executed
            using the given index, ie. jmp 0 executes 
            instructions at line 0.
        jal
            works like jmp, but stores the current location
            in the link register (lnk) before jumping
            to the new location.
        jif
            takes a program location and a register,
            and jumps to the program location iff the
            contents of the given register != 0.
            if the register contains 0, the instruction
            is skipped / does nothing.
        jr 
            takes a register and jumps to the location
            specified in that register (there will be
            an integer in the register specifying a 
            line of the code, not e reference to a 
            location in some complicated way.)
            if the location in the given register doesnt
            exist (negative number or too high for amt of
            lines in the given program), the behaviour is 
            undefined so i gotta specify what happens then
                Would be funny to raise an error of some type,
                and say "Your data isn't where it's supposed to be..."
                    IF its easy, point to the thing that made the problem
                    fx if i can make the thing that fucks up print something
                    then just add the line its on as part of the print?
                    only if possible only if i can and only if i care.
        

FUNCTIONS:
interp :: Program -> Int 
    executes register program, returns
    value stored in rv upon 
    termination. All registers are 0 at 
    the start of program.

loadFromFile :: FilePath -> IO Program
    Takes the name of a file containing
    a register program, and returns an 
    IO action containing that program.

runProgram :: FilePath -> IO ()
    takes name of a file with a register
    program, executes it, outputs the 
    contents of the rv register to the 
    screen in case it terminates.

OTHER
test suite
    find out what this is
    is meant to demonstrate all the instructions
    work as expected.

brief report 
    2-3 pages.

submission
    single zip file, source code for solution
    and report in a PDF format.
    deadline 5 january 23:59

IDEAS:
registers 
    referably just a list, each index corresponding
    to a register.
    The two special registers, rv and lnk,
    also just store values, just slightly more
    important values, so make them:
        index 0 = rv, index 1 = lnk
    and then the rest of the registers, how ever many
    we need, make them correspond to the rest of the
    indexes in the list.
    how to know lenght of list? 
        after parsing data should be lists in lists.
        we can read through and take the amount of different
        registers, sum those, and know how long our
        list of registers needs to be.
            normally rx (for r and an integer) specify
            the register, but we need to add special cases
            for lnk and rv registers, which are just written
            as lnk and rv.

parsing:
    parse the data using the spaces and newlines.
    have one list where you can store a list on
    each index, and each of those lists contains
    one line of the given program,
    i.e:
        movc r2 0
        addc r0 1
        add r1 r0 r1
        jif r2 1
    
    becomes:
        [Movc r2 0,
         Addc r0 1,
         Add r1 r0 r1,
         Jif r2 1]

Functions i think i need:

Parsing :: FilePath -> []
    wherein i need to get better a programming
    and also
    wherein i make the capital letters on the 
    instructions, and add each line to its own
    index in the list.
    also
    add to the list with the qucikest way,
    the appending thing; :
    and then call reverse on the whole list
    once we're done parsing the document,
    and return that as the [] 
 

Types i need:

instructions:
    a type with all the names specified,
    and what exactly they need to do.

    data Instructions =  Mov Reg Reg
                       | Movc Reg Int
                       | Sub Reg Reg
                       | Subc Reg Int

    [Mov R0 R29, Mov R5 R1]

registers:
    the registers are just going to be lists.
    not sure i need a datatype for this actually.
    think maybe i need a function for making a list
    of the right lenght.


QUESTIONS FOR ROBIN

- can i just say my program requires capitalized input?
    - im using dataypes which need to be capitalized and matching on those, so 
      would i need to write a function to capitalize the first letter of every
      sequence of letters, or can i just spcify an input?
      yes

- i needed a very specific function and found a well written one online, which i
  then based, almost entirely, one of my functions on. Am i allowed to essentially
  copy like that?
  no, gotta write my own.
    (or at least not tell him i took it from somewhere)
        rename it, change it a bit just to look different.

- can i format my code-comments however i like?
  is there a convention for annotating my functions?
    up to me

- should i print rv to the terminal upon completion
  or only upon crashing?
    always print.
     (wants to see 55 in the example)


ANSWERS
dont need to secify behaviou, can just let it crash on its own.
Jal: stores location in lnk, but store location + 1 to avoid infinite loop.
    ignore jal example.
Jmp: jumps to the line specified and runs the current
64 bit machine.

important:
idiomatic style, , performance
idiomatic style:
    write and use pure functions; avoid IO as much as possible

    use functions that are as general as possible, e.g. use traverse instead of mapM

    use pattern matching instead of equality checks

    use guards instead of if-then-else expressions

    parse, don't validate; avoid boolean blindness

    prefer where over let

    make your functions as polymorphic as possible and get theorems for free

    write type signatures for all top-level definitions

    employ algebra-driven design and denotational design (basically the same thing)

    use dumb reusable data (the whole talk is interesting, but in particular look at 20:27-29:00)

    make your intent clear in your types and use types that are as precise as possible, e.g. use natural numbers and not integers if you are talking about the length of a list (there are no lists with negative length)

    write total functional programs; avoid partial functions

    use combinators like map and foldr instead of manual recursion


have to write functions that work on my program
test suite: (in different file)
a program he can run which exercises my program in some way.
cover ALL if the if then else, guards, and branches of the
program to see they behave as specified.
fx write programs which tests specific things for each option.
example:

reverse' :: [a] -> [a]
reverse' []     = []
reverse' (x:xs) = reverse xs ++ [x]

to test reverse', we have two branches:
empty list input, or non-empty list input.
here, at least two tests are needed.

test1 = reverse' [] :: [Integer] == []
test2 = reverse' [1,2,3] == [3,2,1]

reversetestsuite = and [t1, t2]

REPORT 
hereunder we note many repititions,
this couldve been boiled down in some way
or another but the task specified completion
using the simplest possible methods, or,
the methods deemed easiest by the taskee,
and this was that.

document choice in regards to jal or jr,
    i.e wether you increase before saving value,
    or jump to value +1

write about idiomatic style, and where it falls short.

how much detail?
    up to us. brief report, 2-3 pages
    dont only describe what the code does (he can read it)
    mention if unconventional way, nice, bad way, obvious way etc.
    but dont describe what, only how or why.


TODO
runProgram
    runs the program using interp
    and loadFromFile
    prints rv incase of termination.
        how to check for termination?

interp
    runs program and returns value in rv
    at the end of program

CHECK FOR VALIDREG AND VALIDINT

how a prograim works:
1. we load the file, parse it to a readbale format.
    loadFromFile, parsing
2. we specify registers full of 0's
    datalist 
3. we specify our types:
    our Program, which is a list of instructions.
    data instructions, which is case-matching
    instructions and Registers.
    data Reg which casematches our registers with 
    their given names.
4. we index our registers, giving each type Reg an int.
    index
5. we DONT run the program
    doing this requires:
    starting the execution of instructions
        we have list of instructions
        as an output from loadFromFile (file)
        we need to specify starting at line
        0, and reading the next instruction.
        for this i have the increment function.
        what we need is this:
        1. read instruction 
            i do this
        2. execute instructions using defInstruction
            hopefully do this in interp
        3. increment our index counter
            hopefully do this in interp
        4. return value in rv 
            both upon completion and crashing.
6. print rv upon completion
7. testSuite segment.
    normally in seperate file
8. done.

